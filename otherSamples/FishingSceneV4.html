<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - GLTFloader + Instancing</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="FishingScene.css" />
    
  </head>

  <body>
    <div id="info">Click to Begin</div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
      import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";

      let camera, scene, renderer;
      var fish, penguin, island, rod, bobber;

      init();
      render();

      function init() {
        //
        const container = document.createElement("div");
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.25,
          20
        );
        camera.position.set(2, 1.5, -0.5);
        camera.lookAt(0, 0, 0);

        scene = new THREE.Scene();

        // Load the background
        new RGBELoader()
          .setPath("../../textures/equirectangular/")
          .load("kloppenheim_06_puresky_2k.hdr", function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;

            scene.background = texture;
            scene.environment = texture;

            // load in red, green and blue cubes for orientation -----------------------------
            const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // green
            const cube1 = new THREE.Mesh(geometry, material);
            cube1.position.set(0, 0.2, 0);
            scene.add(cube1);

            const geometry2 = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material2 = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // red
            const cube2 = new THREE.Mesh(geometry2, material2);
            cube2.position.set(0.2, 0, 0);
            scene.add(cube2);

            const geometry3 = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material3 = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // blue
            const cube3 = new THREE.Mesh(geometry3, material3);
            cube3.position.set(0, 0, 0.2);
            scene.add(cube3);
            
            // // Calibrate tip of rod TODO: make this a child of the rod
            // const geometry4 = new THREE.BoxGeometry(0.005, 0.005, 0.05);
            // const material4 = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            // const cube4 = new THREE.Mesh(geometry4, material4);
            // cube4.position.set(0.15, 0.32, 0.09); // 0.15, 0.32, 0.09 -> offset of rod from rod rotation point
            // scene.add(cube4);

            render();

            // load in models ---------------------------------------------------------------
            // model set up
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath("/otherSamples/jsm/libs/draco/");

            const loader = new GLTFLoader().setPath("../../models/");
            loader.setDRACOLoader(dracoLoader);

            // FishingIsland model
            const glbPathIsland = "FishingIsland.gltf";
            loader.load(glbPathIsland, function (gltf) {
              console.log(gltf);
              island = gltf.scene;
              island.scale.set(0.1, 0.1, 0.1);
              island.position.set(0.35, -0.1, 0.3);
              island.rotation.set(0, 90, 0);
              scene.add(island);
            });

            // Penguin model
            const glbPath = "Penguin.gltf";
            loader.load(glbPath, function (gltf) {
              console.log(gltf);
              penguin = gltf.scene;
              penguin.scale.set(0.06, 0.06, 0.06);
              penguin.position.set(0, 0, 0.03);
              penguin.rotation.set(0, (-10 / 180) * Math.PI, 0);
              scene.add(penguin);
            });

            // Fish model
            const glbPath2 = "Fish.gltf";
            loader.load(glbPath2, function (gltf) {
              console.log(gltf);
              fish = gltf.scene;

              // Fish default position
              fish.scale.set(0.03, 0.03, 0.03);
              fish.position.set(0.4, -0.2, 0.1);
              fish.rotation.set(0, 0, -((45 / 180) * Math.PI));

              scene.add(fish);
            });

            // Fishing rod model
            const glbPath3 = "FishingRod.gltf";
            loader.load(glbPath3, function (gltf) {
              console.log(gltf);
              rod = gltf.scene;

              // Rod default position
              rod.scale.set(0.03, 0.03, 0.03);
              rod.position.set(0, 0.08, 0.1);
              rod.rotation.set(0, 0, -((0 / 180) * Math.PI));

              scene.add(rod);
            });

            // Bobber model
            const glbPath4 = "Bobber.gltf";
            loader.load(glbPath4, function (gltf) {
              console.log(gltf);
              bobber = gltf.scene;

              // Bobber default position
              bobber.scale.set(0.01, 0.01, 0.01);
              bobber.position.set(0.35, -0.15, 0.1);
              bobber.rotation.set(0, 0, 0);

              scene.add(bobber);
            });
          });
        
        // renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        // controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.addEventListener("change", render); // use if there is no animation loop
        controls.minDistance = 0.2;
        controls.maxDistance = 10;
        controls.target.set(0, 0.25, 0);
        controls.update();

        window.addEventListener("resize", onWindowResize);
        
        // // wait for the models to load then start the animation
        // setTimeout(() => {
        //     // replace with game loop later
        //     window.requestAnimationFrame(step);
        // }, 3000);

      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

        render();
      }

      function render() {
        renderer.render(scene, camera);
      }

      // Game mechanics

    </script>
  </body>
</html>
