<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Penguin Fishing Scene</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="FishingScene.css" />
  </head>

  <body>
    <div id="info">
      <p>Click to Begin</p>
      <p>Use mouse to move camera</p>
      <p>Use WASD to move fishing rod, and space to cast or reel in</p>
    </div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
      import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";

      // Scene
      let camera, scene, renderer;

      // Models
      var fish, penguin, island, rod, bobber, alertModel;

      // Timing
      let startTime, prevTime, elapsedTime;
      let animationDone = false;
      let animationPhase = 0;
      let currentAnimation = "idle";
      var currentRodRotation = 0;

      // Game state
      var numFish = 0;
      const targetFish = 5;

      init();
      render();

      function init() {
        //
        const container = document.createElement("div");
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.25,
          20
        );
        camera.position.set(2, 1.5, -0.5);
        camera.lookAt(0, 0, 0);

        scene = new THREE.Scene();
        const clock = new THREE.Clock();

        // Load the background
        new RGBELoader()
          .setPath("../../textures/equirectangular/")
          .load("kloppenheim_06_puresky_2k.hdr", function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;

            scene.background = texture;
            scene.environment = texture;

            // load in red, green and blue cubes for orientation -----------------------------
            const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // green
            const cube1 = new THREE.Mesh(geometry, material);
            cube1.position.set(0, 0.2, 0);
            scene.add(cube1);

            const geometry2 = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material2 = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // red
            const cube2 = new THREE.Mesh(geometry2, material2);
            cube2.position.set(0.2, 0, 0);
            scene.add(cube2);

            const geometry3 = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material3 = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // blue
            const cube3 = new THREE.Mesh(geometry3, material3);
            cube3.position.set(0, 0, 0.2);
            scene.add(cube3);

            // // Calibrate tip of rod TODO: make this a child of the rod
            // const geometry4 = new THREE.BoxGeometry(0.005, 0.005, 0.05);
            // const material4 = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            // const cube4 = new THREE.Mesh(geometry4, material4);
            // cube4.position.set(0.15, 0.32, 0.09); // 0.15, 0.32, 0.09 -> offset of rod from rod rotation point
            // scene.add(cube4);

            render();

            // load in models ---------------------------------------------------------------
            // model set up
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath("/otherSamples/jsm/libs/draco/");

            const loader = new GLTFLoader().setPath("../../models/");
            loader.setDRACOLoader(dracoLoader);

            // FishingIsland model
            const glbPathIsland = "FishingIsland.gltf";
            loader.load(glbPathIsland, function (gltf) {
              console.log(gltf);
              island = gltf.scene;
              island.scale.set(0.1, 0.1, 0.1);
              island.position.set(0.35, -0.1, 0.3);
              island.rotation.set(0, 90, 0);
              scene.add(island);
            });

            // Penguin model
            const glbPath = "Penguin.gltf";
            loader.load(glbPath, function (gltf) {
              console.log(gltf);
              penguin = gltf.scene;
              penguin.scale.set(0.06, 0.06, 0.06);
              penguin.position.set(0, 0, 0.03);
              penguin.rotation.set(0, (-10 / 180) * Math.PI, 0);
              scene.add(penguin);
            });

            // Fish model
            const glbPath2 = "Fish.gltf";
            loader.load(glbPath2, function (gltf) {
              console.log(gltf);
              fish = gltf.scene;

              // Fish default position
              fish.scale.set(0.03, 0.03, 0.03);
              fish.position.set(0.4, -0.2, 0.1);
              fish.rotation.set(0, 0, -((45 / 180) * Math.PI));

              scene.add(fish);
            });

            // Fishing rod model
            const glbPath3 = "FishingRod.gltf";
            loader.load(glbPath3, function (gltf) {
              console.log(gltf);
              rod = gltf.scene;

              // Rod default position
              rod.scale.set(0.03, 0.03, 0.03);
              rod.position.set(0, 0.08, 0.1);
              rod.rotation.set(0, 0, -((0 / 180) * Math.PI));

              scene.add(rod);
            });

            // Bobber model
            const glbPath4 = "Bobber.gltf";
            loader.load(glbPath4, function (gltf) {
              console.log(gltf);
              bobber = gltf.scene;

              // Bobber default position
              bobber.scale.set(0.01, 0.01, 0.01);
              bobber.position.set(0.35, -0.15, 0.1);
              bobber.rotation.set(0, 0, 0);

              scene.add(bobber);
            });

            // Alert (exclamation mark) model
            const glbPath5 = "Alert.gltf";
            loader.load(glbPath5, function (gltf) {
              console.log(gltf);
              alertModel = gltf.scene;

              // Alert default position
              alertModel.scale.set(0.1, 0.1, 0.1);
              alertModel.position.set(0.35, 0, 0.1);
              alertModel.rotation.set(0, 90, 0);

              // hide alert model
              alertModel.visible = false;

              scene.add(alertModel);
            });
          });

        // renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        // controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.addEventListener("change", render); // use if there is no animation loop
        controls.minDistance = 0.2;
        controls.maxDistance = 10;
        controls.target.set(0, 0.25, 0);
        controls.update();

        window.addEventListener("resize", onWindowResize);

        // // wait for the models to load then start the animation
        // setTimeout(() => {
        //     // replace with game loop later
        //     window.requestAnimationFrame(step);
        // }, 3000);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

        render();
      }

      function render() {
        renderer.render(scene, camera);
      }

      // Game mechanics ---------------------------------------------------------------
      // Get user input from keyboard
      document.addEventListener("keydown", (event) => {
        const keyName = event.key;

        if (keyName === "ArrowUp" || keyName === "w") {
          // move rod up (up to 0 rad)
          rod.rotation.z += 0.05;

          if (rod.rotation.z > 0) {
            rod.rotation.z = 0;
          }
          console.log(rod.rotation.z);
        } else if (keyName === "ArrowDown" || keyName === "s") {
          // move rod down (up to -0.8 rad)
          rod.rotation.z -= 0.05;

          if (rod.rotation.z < -0.8) {
            rod.rotation.z = -0.8;
          }
          console.log(rod.rotation.z);
        } else if (keyName === "ArrowRight" || keyName === "d") {
          // move rod left (up to -5.8 rad)
          rod.rotation.y += 0.1;

          if (rod.rotation.y > -6) {
            rod.rotation.y = -6;
          }
          console.log(rod.rotation.y);
        } else if (keyName === "ArrowLeft" || keyName === "a") {
          // move rod right (up to -6.5 rad)
          rod.rotation.y -= 0.1;

          if (rod.rotation.y < -6.5) {
            rod.rotation.y = -6.5;
          }
          console.log(rod.rotation.y);
        } else if (keyName === " ") {
          if (!(currentAnimation === "cast")) {
            resetAnimationParams();
            window.requestAnimationFrame(castAnimation);
          }
          
        }

        // update rod position
        render();
      });

      function resetAnimationParams() {
        startTime = undefined;
        animationPhase = 0;
        animationDone = false;
      }

      function castAnimation(timestamp) {
        if (startTime === undefined) {
          startTime = timestamp;
          currentRodRotation = rod.rotation.z;
          currentAnimation = "cast"
        }

        const elapsed = timestamp - startTime;
        if (prevTime !== timestamp) {
          switch (animationPhase) {
            case 0:
              // flick rod up
              rod.rotation.z += 0.1;

              if (rod.rotation.z >= currentRodRotation + 0.5) {
                rod.rotation.z = currentRodRotation + 0.5;
              }

              if (rod.rotation.z === currentRodRotation + 0.5) {
                animationPhase = 1;
              }
              break;
            case 1:
                // flick rod down
                rod.rotation.z -= 0.1;

                if (rod.rotation.z <= currentRodRotation) {
                  rod.rotation.z = currentRodRotation
                }

                if (rod.rotation.z === currentRodRotation) {
                  animationPhase = 2;
                }

              break;
            case 2:
              animationDone = true;
              currentAnimation = "idle"
          }
          console.log(rod.rotation.z)

          render();
        }

        prevTime = timestamp;
        if (!animationDone) {
          // add some delay
          setTimeout(() => {
            window.requestAnimationFrame(castAnimation);
          }, 50);
        }
      }
    </script>
  </body>
</html>
